program amatter
!     importing concrete type library
      use, intrinsic :: iso_fortran_env

      implicit none
!     scalar parameters
      integer(int64),parameter :: np = 400
      integer(int64),parameter :: nworms = 216
      integer(int64),parameter :: nsteps = 2000000
      real(real64),parameter :: kspring = 146436d0
      real(real64),parameter :: kbend = 40.0d0
      !scalar variables
      real(real64) :: length0 = 0.8d0
      real(real64) :: length2,lengthmax
      real(real64) :: twopi,pi,pio4
      integer(int64) :: scell,scnab
      integer(int64) :: iwalldrive = 1
      real(real64) :: rcut = 2.5d0
      real(real64) :: rcutsmall = 2.d0**(1./6.)
      real(real64) :: r2cut,r2cutsmall,rwall,r2inside
      real(real64) :: density,hx,hy,hyo2,hxo2,ss,t,dto2
      real(real64) :: dx,dy,xang,dot
      real(real64) :: thetanow,a,rmin
      integer(int32) :: iseed = 6487735
      integer(int64) :: nstepso500 = nsteps/500
      integer(int64) :: npm1,npm2
      real(real64) :: fdogic = 0.06d0
      real(real64) :: fdogicwall = 0.0d0
      real(real64) :: fdep = 1.0d0
      real(real64) :: fdepwall = 0.0d0
      real(real64) :: diss = 0.08d0
      real(real64) :: gnoise = 0.8d0 * (0.8d0/dsqrt(10.0d0))
      real(real64) :: dt = 0.02

      ! iterable variables
      integer(int64) :: itime,iw,i
      ! fileunit variables
      integer(int32) :: xyzfileunit,logfileunit,datfileunit

      ! allocatable arrays
      real(real64),dimension(nworms,np) :: x,y,vx,vy,vxave,vyave,fx,fy,fxold,fyold
      real(real64),dimension(np) :: savex,savey
      integer(int64),dimension(nworms) :: ireverse
      integer(int64),dimension(9) :: ddx,ddy
      integer(int64),dimension(504*504) :: hhead
      integer(int64),dimension(nworms*np) :: ipointto
      integer(int64),dimension(nworms,np) :: nnab
      character*1,dimension(nworms) :: col
      character*1,dimension(10) :: collist
      character(len=:), allocatable :: fmtoutput,datoutput

      fmtoutput = '(A2,1x,f8.4,1x,f8.4,1x,f8.4)'
      datoutput = '(1x,f12.6,1x,f12.6,1x,f12.6,1x,f12.6)'

      ! variable assignments
      dto2 = dt*0.5d0
      r2cut = rcut**2
      r2cutsmall = r2cutsmall**2
      rwall = 125.d0*rcutsmall*dsqrt(2.d0)
      r2inside=(rwall-rcutsmall)**2

      twopi = 8.0d0*datan(1.d0)
      pi = 0.5d0 * twopi
      pio4 = pi*0.5d0

      length2 = 2.0d0*length0
      lengthmax = (length0) * float(np-1)

      thetanow = 5.0d0*pi
      a = 0.24
      rmin = a*thetanow

      density = nworms*np/(pi*rwall**2)
      print *, "rwall",rwall
      print*, "nworms",nworms
      print*, "density",density

      hx = 2.d0*rwall+1.d0
      hy = hx
      hxo2 = 0.5*hx
      hyo2 = 0.5*hy

      collist(1) = 'A'
      collist(2) = 'B'
      collist(3) = 'C'
      collist(4) = 'D'
      collist(5) = 'E'
      collist(6) = 'F'
      collist(7) = 'G'
      collist(8) = 'H'
      collist(9) = 'I'
      collist(10) = 'J'

      ! random number initialization
      ! https://cyber.dabamos.de/programming/modernfortran/random-numbers.html
      ss = rand(iseed)
      ss = rand()
      !call random_seed()
      call random_init(repeatable=.true.,image_distinct=.false.)
!     array for locating neighbor cells
      ddx(1) = 1
      ddy(1) = 0

      ddx(2) = 1
      ddy(2) = 1

      ddx(3) = 0
      ddy(3) = 1

      ddx(4) = -1
      ddy(4) = 1

      ddx(5) = -1
      ddy(5) = 0

      ddx(6) = -1
      ddy(6) = -1

      ddx(7) = 0
      ddy(7) = -1

      ddx(8) = 1
      ddy(8) = -1

      ddx(9) = 0
      ddy(9) = 0

      open(newunit=xyzfileunit,file='amatter.xyz',status='unknown')
      open(newunit=logfileunit,file='amatter-debug.dat',status='unknown')

      call init_worms(x,y,vx,vy,fx,fy,savex,savey,ireverse,nworms,np,a,thetanow,hx,hy,length0,xyzfileunit,fmtoutput)

      ! MAIN LOOP
      do itime = 1,nsteps
         if (mod(itime,200).eq.0) then
            print *, itime
         endif

         t = float(itime)*dt

         !update positions and store old forces
         call update_pos(nworms,np,x,y,vx,vy,fx,fy,fxold,fyold,dt)
         !calculate forces
         call calc_forces(nworms,np,x,y,fx,fy)
         !add wall driving force and wall interactions
         call wall_interactions(nworms,np,x,y,vx,vy,vxave,vyave,fx,fy,nnab,diss,hx,hy,r2inside,iwalldrive,fdogicwall)
         !assign particles to their cells
         do i = 1,size(hhead) !every cell is initially empty; hhead = -1 for all
            hhead(i) = -1
         enddo
         call assign_cells(nworms,np,x,y,vx,vy,vxave,vyave,fx,fy,hhead,nnab,ipointto,ddx,ddy,hx,hy,rcutsmall)
         !update velocities and normalize average velocities
         !velocities are one timestep behind
         call update_vel(nworms,np,vx,vy,vxave,vyave,fx,fy,fxold,fyold,nnab,dto2)
         if (mod(itime,2000).eq.0) then
            write(xyzfileunit,*) nworms*np+4
            write(xyzfileunit,*) "# 0"
            do iw = 1,nworms
               dx = x(iw,1) - hxo2
               dy = y(iw,1) - hyo2
               xang = atan2(dy,dx)
               dot = (x(iw,1)-x(iw,np))*(-dsin(xang)) + (y(iw,1)-y(iw,np))*dcos(xang)
               if (dot.ge.0.0d0) then
                  do i = 1,np
                     write(xyzfileunit,fmtoutput) 'A ',x(iw,i),y(iw,i),0.0d0
                  enddo
               else
                  do i = 1,np
                     write(xyzfileunit,fmtoutput) 'B ',x(iw,i),y(iw,i),0.0d0
                  enddo
               endif
            enddo
            write(xyzfileunit,fmtoutput) 'E ',hxo2-rwall,hyo2-rwall,0.0d0
            write(xyzfileunit,fmtoutput) 'E ',hxo2-rwall,hyo2+rwall,0.0d0
            write(xyzfileunit,fmtoutput) 'E ',hxo2+rwall,hyo2-rwall,0.0d0
            write(xyzfileunit,fmtoutput) 'E ',hxo2+rwall,hyo2+rwall,0.0d0
         endif

         if (mod(itime,5000).eq.0) then
            open(unit=datfileunit,file='amatter_data.dat',status='unknown')
            do iw = 1,nworms
               do i = 1,np
                  write(datfileunit,datoutput) x(iw,i),y(iw,i),vx(iw,i),vy(iw,i)
               enddo
            enddo
            close(unit=datfileunit)
         endif
      enddo
      close(unit=xyzfileunit)
      close(unit=logfileunit)

      open(datfileunit,file='amatter_data.dat',status='unknown')
      write(datfileunit,*) nworms,np
      write(datfileunit,*) diss,gnoise,fdogic,rwall,fdep
      do iw = 1,nworms
         do i = 1,np
            write(datfileunit,datoutput) x(iw,i),y(iw,i),vx(iw,i),vy(iw,i)
         enddo
      enddo
      close(unit=datfileunit)
      print*, "done"




      ! subroutines and functions
      contains
        subroutine update_vel(nworms,np,vx,vy,vxave,vyave,fx,fy,fxold,fyold,nnab,dto2)
          integer(int64),intent(in) :: nworms,np
          real(real64),intent(in out) :: vx(:,:),vy(:,:),vxave(:,:),vyave(:,:),fx(:,:),fy(:,:),fxold(:,:),fyold(:,:)
          integer(int64),intent(in) :: nnab(:,:)
          real(real64),intent(in) :: dto2
          integer(int64) :: iw,i

          do iw = 1,nworms
             do i = 1,np
                vx(iw,i)=vx(iw,i)+dto2*(fx(iw,i)+fxold(iw,i))
                vy(iw,i)=vy(iw,i)+dto2*(fy(iw,i)+fyold(iw,i))
                vxave(iw,i)=vxave(iw,i)/nnab(iw,i)
                vyave(iw,i)=vyave(iw,i)/nnab(iw,i)
             enddo
          enddo
        end subroutine update_vel

        subroutine assign_cells(nworms,np,x,y,vx,vy,vxave,vyave,fx,fy,hhead,nnab,ipointto,ddx,ddy,hx,hy,rcutsmall)
          integer(int64),intent(in) :: nworms,np
          real(real64),intent(in out) :: x(:,:),y(:,:),vx(:,:),vy(:,:),vxave(:,:),vyave(:,:),fx(:,:),fy(:,:)
          integer(int64),intent(in out) :: hhead(:),ddx(:),ddy(:),nnab(:,:),ipointto(:)
          real(real64),intent(in) :: hx,hy,rcutsmall
          integer(int64) :: iworm,jworm,ip,jp,ii,jj,icell,jcell,i,j,ip1,jp1
          integer(int64) :: scell,idir,icnab,jcnab,inogo,scnab
          real(real64) :: dddx,dddy,r2,riijj,ffor,ffx,ffy,dxi,dxj,dyi,dyj,ri,r,dx,dy,dcell
          integer(int64) :: nxcell,nycell,ncells

          nxcell = (hx/rcutsmall) - 1
          nycell = (hy/rcutsmall) - 1
          ncells = nxcell*nycell
          dcell = hx/float(nxcell)
          do iworm = 1,nworms
             do ip = 1,np
                ii = (iworm-1)*np+ip
                icell = 1+floor(x(iworm,ip)/dcell)
                jcell = 1+floor(y(iworm,ip)/dcell)
                if (icell.gt.nxcell.or.icell.lt.1) then
                   print *, "nxcell",nxcell
                   print *, "icell out of bounds",iworm,ip,x(iworm,ip)
                   print *, "icell= ",icell, "dcell =",dcell
                   do i = 1,np
                      print *, "check positions:",i,x(iworm,i)
                   enddo
                   stop
                endif

                if (jcell.gt.nycell.or.jcell.lt.1) then
                   print*,"nycell",nycell
                   print*,"jcell out of bounds",iworm,ip,y(iworm,ip)
                   print*,"icell=",icell,"dcell=",dcell
                   do i = 1,np
                      print *, "check positions:",y(iworm,i)
                   enddo
                   stop
                endif
             enddo
          enddo

          do icell = 1,nxcell
             do jcell = 1,nycell
                scell = icell+(jcell-1)*nxcell
                if (hhead(scell).ne.-1) then
                   !there are paticles in the cell called scell so check all the neighbor cells
                   do idir = 1,9
                      icnab = icell+ddx(idir)
                      if (icnab.gt.nxcell) cycle
                      if (icnab.eq.0) cycle

                      jcnab = jcell + ddy(idir)
                      if (jcnab.gt.nycell) cycle
                      if (jcnab.eq.0) cycle

                      scnab = icnab + (jcnab-1)*nxcell
                      if (hhead(scnab).ne.-1) then
                         ! there are particles in the cell called scnab
                         ii = hhead(scell)
                         do while (ii.gt.0)
                            iworm = i+int((ii-1/np))
                            ip = ii-np*(iworm-1)
                            jj = hhead(scnab)
                            do while (jj.gt.0)
                               jworm = 1+int((jj-1)/np)
                               jp = jj-np*(jworm-1)
                               if (iworm.eq.jworm.and.abs(ip-jp).le.2) then
                                  inogo = 1
                               else
                                  inogo = 0
                               endif

                               if (ii.lt.jj.and.inogo.eq.0) then
                                  dddx=x(jworm,jp)-x(iworm,ip)
                                  dddy=y(jworm,jp)-y(iworm,ip)
                                  r2 = dddx*dddx + dddy*dddy
                                  riijj = dsqrt(r2)
                                  ! add attractive force fdep between all pairs
                                  if (r2.le.r2cutsmall) then
                                     ffor = -48.0d0*r2**(-7) + 24.0d0*r2**(-4)+fdep/riijj
                                     ffx = ffor*dddx
                                     ffy = ffor*dddy

                                     fx(iworm,ip) = fx(iworm,ip) + ffx
                                     fx(iworm,jp) = fx(jworm,jp) - ffx
                                     fy(iworm,ip) = fy(iworm,ip) + ffy
                                     fy(jworm,jp) = fy(jworm,jp) -ffy

                                     !take these neighbors into account in calculating vxave and vyave
                                     vxave(iworm,ip)=vxave(iworm,ip)+vx(jworm,jp)
                                     vyave(iworm,ip)=vyave(iworm,ip)+vy(jworm,jp)
                                     nnab(iworm,ip)=nnab(iworm,ip)+1
                                     vxave(jworm,jp)=vxave(jworm,jp)+vx(iworm,ip)
                                     vyave(jworm,jp)=vyave(jworm,jp)+vy(iworm,ip)
                                     nnab(jworm,jp)=nnab(jworm,jp)+1

                                     !add dogic drive to interacting pairs
                                     !first calculate unit vectors along each worm
                                     ip1 = ip+1
                                     if (ip1.le.np) then
                                        dxi = x(iworm,ip1) - x(iworm,ip)
                                        dyi = y(iworm,ip1) - y(iworm,ip)
                                     else
                                        dxi = x(iworm,ip) - x(iworm,ip-1)
                                        dyi = y(iworm,ip) - y(iworm,ip-1)
                                     endif

                                     jp1 = jp + 1
                                     if(jp1.le.np) then
                                        dxj = x(jworm,jp1) - x(jworm,jp)
                                        dyj = y(jworm,jp1) - y(jworm,jp)
                                     else
                                        dxj = x(jworm,jp) - x(jworm,jp-1)
                                        dyj = y(jworm,jp) - y(jworm,jp-1)
                                     endif

                                     !if the two vectors have any component pointing in the opposite direction
                                     if(dxi*dxj+dyi*dyi.le.0.0d0) then
                                        !normalize those vectors to make them unit vectors
                                        ri = dsqrt(dxi*dxi + dyi*dyi)
                                        dxi = dxi/ri
                                        dyi = dyi/ri
                                        ! now they are both unit vectors, find the direction for the force
                                        dx = (dxi-dxj)/2.0d0
                                        dy = (dyi-dyj)/2.0d0
                                        r = dsqrt(dx*dx + dy*dy)
                                        dx=dx/r
                                        dy=dy/r
                                        ! add an extra attractive component where kinesin drive is present
                                        ffx = fdogic*dx + 0.7d0*dddx/riijj
                                        ffy = fdogic*dy + 0.7d0*dddy/riijj

                                        fx(iworm,ip) = fx(iworm,ip) + ffx
                                        fx(jworm,jp) = fx(jworm,jp) - ffy
                                        fy(iworm,ip) = fy(iworm,ip) + ffy
                                        fy(jworm,jp) = fy(jworm,jp) - ffy
                                     endif
                                  endif
                               endif
                               jj = ipointto(jj)
                            enddo
                            ii = ipointto(ii)
                         enddo
                      endif
                   enddo
                endif
             enddo
          enddo
        end subroutine assign_cells

        pure subroutine update_pos(nworms,np,x,y,vx,vy,fx,fy,fxold,fyold,dt)
          integer(int64), intent(in) :: nworms,np
          real(real64), intent(in out) :: x(:,:),y(:,:),vx(:,:),vy(:,:),fx(:,:),fy(:,:),fxold(:,:),fyold(:,:)
          real(real64), intent(in) :: dt
          real(real64) :: dt2o2
          integer(int64) :: iw,i

          dt2o2 = dt*dt*0.5d0

          do iw = 1,nworms
             do i = 1,np
                x(iw,i) = x(iw,i) + vx(iw,i)*dt + fx(iw,i)*dt2o2
                y(iw,i) = y(iw,i) + vy(iw,i)*dt + fx(iw,i)*dt2o2

                fxold(iw,i) = fx(iw,i)
                fyold(iw,i) = fy(iw,i)
             enddo
          enddo
        end subroutine update_pos

        subroutine calc_forces(nworms,np,x,y,fx,fy)
          integer(int64),intent(in) :: nworms,np
          real(real64),intent(in out) :: x(:,:),y(:,:),fx(:,:),fy(:,:)
          real(real64) :: v1,v2,fac,g1,th,twopi,dx,dy,r,ff,ffx,ffy
          real(real64) :: x2,y2,x3,y3,x4,y4,x23,y23,x34,y34,r23,r34,cosvalue,sinvalue,dot,rsq
          real(real64) :: f2x,f2y,f4x,f4y,f3x,f3y
          real(real64) :: rand1,rand2,rand3 ! random number stores
          integer(int64) :: iw,i,ip1,i2,i3,i4
          !zero out force arrays and add Gaussian noise
          twopi = 8.0d0*datan(1.d0)
          rsq = 0.0d0
          do iw = 1,nworms
             do i = 1,np
                do while (rsq.ge.0.999.or.rsq.le.0.001)
                   call random_number(rand1)
                   call random_number(rand2)
                   v1 = 2.0d0*rand1-1.0d0
                   v2 = 2.0d0*rand2-1.0d0
                   rsq = v1*v1 + v2*v2
                enddo
                fac = dsqrt(-2.0d0*dlog(rsq)/rsq)
                g1 = v1*fac*gnoise

                call random_number(rand3)
                th = rand3*twopi

                fx(iw,i) = g1*dcos(th)
                fy(iw,i) = g1*dsin(th)
             enddo
          enddo
          !first set of springs
          do iw = 1,nworms
             do i = 1,np-1
                ip1 = i+1
                dx = x(iw,ip1)-x(iw,1)
                dy = y(iw,ip1)-y(iw,1)

                r = dsqrt(dx*dx+dy*dy)
                ff = -kspring*(r-length0)/r
                ffx = ff*dx
                ffy = ff*dy
                fx(iw,ip1) = fx(iw,ip1)+ffx
                fx(iw,i) = fx(iw,i)-ffx
                fy(iw,ip1) = fy(iw,ip1)+ffy
                fy(iw,i) = fy(iw,i)-ffy
             enddo
          enddo
          !bond bending terms
          do iw = 1,nworms
             do i2 = 1,np-2
                i3 = i2+1
                i4 = i2+2
                x2 = x(iw,i2)
                y2 = y(iw,i2)
                x3 = x(iw,i3)
                y3 = y(iw,i3)
                x4 = x(iw,i4)
                y4 = y(iw,i4)
                y23 = y3-y2
                y34 = y4-y3
                x23 = x3-x2
                x34 = x4-x3
                r23 = dsqrt(x23*x23 + y23+y23)
                r34 = dsqrt(x34*x34 + y34*y34)

                cosvalue = (x23*x34 + y23*y34)/(r23*r34)
                if (cosvalue.gt.1.0d0) then
                   cosvalue = 1.0d0
                endif
                sinvalue = dsqrt(1.0d0-cosvalue*cosvalue)

                ff = -kbend*sinvalue/(r23*r34)
                dot = x23*x34 + y23*y34

                fac = dot/(r23*r23)
                f2x = ff*(x34-fac*x23)
                f2y = ff*(y34-fac*y23)

                fac = dot/(r34*r34)
                f4x = ff*(fac*x34-x23)
                f4y = ff*(fac*y34 - y23)

                f3x = -f2x-f4x
                f3y = -f2y-f4y

                fx(iw,i2) = fx(iw,i2)+f2x
                fy(iw,i2) = fx(iw,i2)+f2y

                fx(iw,i3) = fx(iw,i3)+f3x
                fy(iw,i3) = fx(iw,i3)+f3y

                fx(iw,i4) = fx(iw,i4)+f4x
                fy(iw,i4) = fy(iw,i4)+f4y

             enddo
          enddo
       end subroutine calc_forces

       subroutine wall_interactions(nworms,np,x,y,vx,vy,vxave,vyave,fx,fy,nnab,diss,hx,hy,r2inside,iwalldrive,fdogicwall)
         integer(int64), intent(in) :: nworms,np,iwalldrive
         real(real64),intent(in) :: diss,hx,hy,r2inside,fdogicwall
         integer(int64),intent(in out) :: nnab(:,:)
         real(real64), intent(in out) :: x(:,:),y(:,:),vx(:,:),vy(:,:),vxave(:,:),vyave(:,:),fx(:,:),fy(:,:)
         real(real64) :: hxo2,hyo2,dx,dy,r2,xwall,ywall,rr2,ffor,dxi,dyi,ri,dxj,dyj,th,ffx,ffy
         integer(int64) :: iw,i,ip1

         hxo2 = hx*0.5d0
         hyo2 = hy*0.5d0
          ! wall-worm interactions, dissipation force proportional to velocity
          do iw = 1,nworms
             do i = 1,np
                ! dissipation proportional to v relative to local average
                fx(iw,i) = fx(iw,i)-diss*(vx(iw,i)-vxave(iw,i))
                fy(iw,i) = fx(iw,i)-diss*(vy(iw,i)-vyave(iw,i))

                !zero out vxave and vyave
                vxave(iw,i) = vx(iw,i)
                vyave(iw,i) = vy(iw,i)
                nnab(iw,i) = 1
                ! calculate distance to the center
                dx = x(iw,i)-hxo2
                dy = x(iw,i)-hyo2
                r2 = (dx*dx+dy*dy)
                if (r2.ge.r2inside) then
                   ! find the nearest spot on the wall
                   th = atan2(dx,dy)
                   xwall = hxo2+rwall*dcos(th)
                   ywall = hyo2+rwall*dsin(th)
                   dx = xwall-x(iw,i)
                   dy = ywall-y(iw,i)
                   rr2 = dx*dx+dy*dy
                   !r = dsqrt(rr2)

                   !ffor = -48.0d0*rr2**(-7) + 24.0d0*rr2**(-4) + fdepwall/r
                   ffor = -48.0d0*rr2**(-7) + 24.0d0*rr2**(-4)
                   ! turn on dogic drive at the wall
                   if (iwalldrive.eq.1) then
                      ip1 = i + 1
                      if (ip1.le.np) then
                         dxi = x(iw,ip1)-x(iw,i)
                         dyi = y(iw,ip1)-y(iw,i)
                      else
                         dxi = x(iw,i) - x(iw,i-1)
                         dyi = y(iw,i) - y(iw,i-1)
                      endif

                      ri = dsqrt(dxi*dxi + dyi*dyi)
                      dxi = dxi/ri
                      dyi = dyi/ri
                      ! calculate the unit vector along the wall
                      dxj = dsin(th)
                      dyj = dcos(th)

                      ! if the vectors are not antiparallel, reverse the vector along the wall
                      if(ri*ri.gt.0.0d0) then
                         dxj = -dxj
                         dyj = -dyj
                      endif

                      ! if the two vectors have any component pointing in opposite directions
                      if(ri*ri.lt.0.0d0) then
                         !find the direction for the force
                         dx = (dxi-dxj)/2.0d0
                         dy = (dyi-dyj)/2.0d0

                         !normalize the direction vector
                         ri = dsqrt(dx*dx +dy*dy)
                         dx = dx/ri
                         dy = dy/ri

                         ffx = fdogicwall*dx
                         ffy = fdogicwall*dy
                         fx(iw,i) = fx(iw,i) + ffx
                         fy(iw,i) = fy(iw,i) + ffy
                      endif
                   endif
                endif
             enddo
          enddo
        end subroutine wall_interactions

        subroutine init_worms(x,y,vx,vy,fx,fy,savex,savey,ireverse,nworms,np,a,thetanow,hx,hy,length0,datafileunit,fmtoutput)
          integer(int64),intent(in out) :: ireverse(:)
          integer(int64),intent(in) :: nworms,np
          integer(int32),intent(in) :: datafileunit
          real(real64),intent(in out) :: x(:,:),y(:,:),vx(:,:),vy(:,:),fx(:,:),fy(:,:),savex(:),savey(:)
          real(real64),intent(in out) :: a,thetanow,hx,hy,length0
          character(len=*),intent(in) :: fmtoutput
          real(real64) :: rand1 ! random number store
          real(real64) :: xangle,hxo2,hyo2,r,dth,dx,dy,xang,rx,ry,dot
          integer(int64) :: iw,i,ip,ireadsaved,nworms1

          hxo2 = hx*0.5d0
          hyo2 = hx*0.5d0
          do iw = 1,nworms
             ireverse(iw) = 0
             call random_number(rand1)
             if (rand1.le.0.5d0) then
                ireverse(iw) = 1
             endif

             do i = 1,np
                r = a*thetanow
                dth = length0/r
                thetanow = thetanow+dth
                x(iw,i) = hxo2+r*dcos(thetanow)
                y(iw,i) = hxo2+r*dsin(thetanow)
                xangle = atan2(y(iw,i)-hyo2,x(iw,i)-hxo2)
                ! giving them an initial velocity going around the circle
                !vx(iw,i)=-dsin(xangle)*0.2d0*float(ireverse(iw))
                !vy(iw,i)=dcos(xangle)*0.2d0*float(ireverse(iw))
                !vx(iw,i)=-dsin(xangle)*0.2d0
                !vy(iw,i)=dcos(xangle)*0.2d0
                vx(iw,i) = 0.0d0
                vy(iw,i) = 0.0d0
                fx(iw,i) = 0.0d0
                fy(iw,i) = 0.0d0
             enddo
             thetanow = thetanow + 4.0d0*dth
          enddo

          ! reversing some of the worms
          do iw = 1,nworms
             call random_number(rand1)
             col(iw) = collist(1+int(rand1*5.0d0))
             if (ireverse(iw).eq.1) then
                do i = 1,np
                   savex(i) = x(iw,i)
                   savey(i) = y(iw,i)
                enddo

                do ip = 1,np
                   x(iw,ip) = savex(np+1-ip)
                   y(iw,ip) = savex(np+1-ip)
                enddo
             endif
          enddo

          ireadsaved = 0
          nworms1 = 0
          if(ireadsaved.eq.1) then
             print*, "opening saved datafiles not supported yet"
          endif

          write(datafileunit,*) nworms*np+4
          write(datafileunit,*) "# 0"
          do iw = 1,nworms
             dx = x(iw,1) - hxo2
             dy = y(iw,1) - hyo2
             xang = atan2(dy,dx)
             rx = -dsin(xang)
             ry = dcos(xang)
             dot = (x(iw,1)-x(iw,np))*rx + (y(iw,1)-y(iw,np))*ry
             if (dot.ge.0.0d0) then
                do i = 1,np
                   write(datafileunit,fmtoutput)'A ',x(iw,i),y(iw,i),0.0d0
                enddo
             else
                do i = 1,np
                   write(datafileunit,fmtoutput)'B ',x(iw,i),y(iw,i),0.0d0
                enddo
             endif
          enddo

          ! writing out the corner particles for display
          write(datafileunit,fmtoutput)'E ',hxo2-rwall,hyo2-rwall,0.0d0
          write(datafileunit,fmtoutput)'E ',hxo2-rwall,hyo2+rwall,0.0d0
          write(datafileunit,fmtoutput)'E ',hxo2+rwall,hyo2-rwall,0.0d0
          write(datafileunit,fmtoutput)'E ',hxo2+rwall,hyo2+rwall,0.0d0
        end subroutine init_worms
end program amatter
